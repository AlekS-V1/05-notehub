## Створено репозиторій 05-notehub
При здачі роботи надаються два посилання: на вихідні файли (репозиторій) та на робочу сторінку завдання, розгорнуту на Vercel.
Проєкт створено за допомогою Vite.
Під час запуску коду в консолі не повинно бути помилок або попереджень.
Для кожного компонента у папці src/components має бути окрема папка, яка містить файл самого React компонента та файл його стилів. Назва папки, файлу компонента (з розширенням .tsx) та файлу стилів (перед .module.css) однакова і відповідає назвам, вказаним у завданнях (якщо вони були).


У кожній папці компонента мають бути:
Файл компонента з розширенням .tsx (наприклад, App.tsx);
Файл стилів, назва якого закінчується на .module.css, з такою самою назвою (наприклад, App.module.css).


Для експорту компонентів використовується експорт за замовчуванням (export default).
Загальні типи, які використовуються в кількох компонентах, винесені в окремий файл (src/types/note.ts). Типи та інтерфейси, які стосуються лише одного компонента, оголошені безпосередньо у файлі цього компонента.
Для типізації пропсів компонентів використовується interface.
Інтерфейс для пропсів компонента називається за схемою: Ім’яКомпонентаProps (наприклад, UserCardProps).
Всі події в колбеках компонентів мають бути типізовані.
Для виконання HTTP-запитів використовується бібліотека axios.
TypeScript-код має бути чистим, зрозумілим і відформатованим за допомогою Prettier.
Стилізація виконується за допомогою CSS-модулів.
Використовується modern-normalize для уніфікації стилів у різних браузерах.


# Додаток NoteHub



Створіть застосунок для зберігання, створення, видалення та пошуку нотаток. Подивіться демо-відео роботи застосунку.







### Бекенд



Для роботи з колекцією нотаток використовуйте готовий бекенд. Документація до нього доступна за посиланням:



https://notehub-public.goit.study/api/docs



Щоб працювати з бекендом, вам потрібно отримати персональний ключ доступу прив’язаний до вашої пошти. Це буде зручно зробити прямо в документації бекенда.





З міркувань безпеки не зберігайте токен безпосередньо в коді. Замість цього використовуйте змінну оточення, наприклад: VITE_NOTEHUB_TOKEN.



При роботі з колекцією нотаток бекенд очікує, що токен передаватиметься в заголовку Authorization у форматі рядка:



"Bearer ваш_токен"



Після створення токену до вашої персональної колекції буде автоматично додано 40 тестових нотаток, щоб ви могли одразу працювати з готовими даними та не витрачати час на створення їх вручну.



### Структура коду



Ознайомтесь з документацією бекенда. Він має маршрути для отримання списку нотаток та роботі з ними (створення, видалення тощо).



Створіть та винесіть інтерфейс Note для типізації однієї нотатки у файл src/types/note.ts і використовуйте його у компонентах.



Функції для виконання HTTP-запитів винесіть в окремий файл src/services/noteService.ts. Типізуйте їх параметри, результат, який вони повертають, та відповідь від Axios. У вас мають бути наступні функції:

fetchNotes : має виконувати запит для отримання колекції нотаток із сервера. Повинна підтримувати пагінацію (через параметр сторінки) та фільтрацію за ключовим словом (пошук);
createNote: має виконувати запит для створення нової нотатки на сервері. Приймає вміст нової нотатки та повертає створену нотатку у відповіді;
deleteNote: має виконувати запит для видалення нотатки за заданим ідентифікатором. Приймає ID нотатки та повертає інформацію про видалену нотатку у відповіді.




### Типізація



Загальні інтерфейси, які пов’язані з сутністю нотаток (Note, NoteTag) мають бути у файлі — src/types/note.ts.



Інтерфейси, які описують відповіді http-запитів (FetchNotesResponse і т.д.) та параметри функцій, які виконують http-запити у — src/services/noteService.ts.



Інтерфейси, які описують пропси компонентів у — файлах відповідних компонентів.





## Компоненти



У цьому завданні вам потрібно самостійно створити та реалізувати логіку наступних компонентів:

App – контейнер додатка
NoteList – колекція нотаток
Modal – універсальний компонент модального вікна, який може відображати будь-який вміст, переданий через children
NoteForm – форма створення нотатки
Pagination – елемент управління пагінацією
SearchBox – текстове поле для пошуку по колекції


Стилі для всіх компонентів вже створені. Скопіюй їх із цього репозиторію: https://github.com/goitacademy/react-notehub-styles. Після створення своїх компонентів скопіюй відповідні .module.css файли у відповідні папки в src/components.


### Контейнер додатка



Компонент App є контейнером для решти компонентів і поки що створює таку розмітку:


```js
<div className={css.app}>
	<header className={css.toolbar}>
		{/* Компонент SearchBox */}
		{/* Пагінація */}
		{/* Кнопка створення нотатки */}
  </header>
</div>
```


В майбутному в хедері буде додаткова розмітка елементів пошуку, пагінації та відкриття модального вікна для створення нотатки.



### Колекція нотаток



При першому завантаженні додатка користувачу потрібно відображати список його власних нотаток.



Компонент NoteList – це список нотаток, додай його в App під хедером. Компонент NoteList має створювати DOM-елемент наступної структури:


```ts
<ul className={css.list}>
	{/* Набір елементів списку нотаток */}
  <li className={css.listItem}>
    <h2 className={css.title}>Note title</h2>
    <p className={css.content}>Note content</p>
    <div className={css.footer}>
      <span className={css.tag}>Note tag</span>
      <button className={css.button}>Delete</button>
    </div>
  </li>
</ul>
```


Для отримання списку нотаток з бекенда, всіх інших запитах по роботі з колекцією нотаток та збереження серверних даних використовуйте TanStack Query.



Додайте умову, щоб компонент NoteList рендерився лише в тому випадку, якщо в колекції нотаток є хоча б один елемент.



### Пагінація



Бекенд завжди повертає пагіновану колекцію нотаток. Тому потрібно додати до компонента App компонент Pagination, який надає користувачеві можливість перемикатися між сторінками колекції. Реалізуйте компонент Pagination з використанням бібліотеки React Paginate.



До http-запиту потрібно додати параметри page та perPage. Наприклад:



GET https://notehub-public.goit.study/api/notes?page=1&perPage=12



Додайте умову, щоб компонент Pagination рендерився лише в тому випадку, якщо кількість сторінок колекції нотаток більше 1.



### Створення нової нотатки



Додайте в хедер застосунку кнопку для створення нової нотатки:


```html
<button className={css.button}>Create note +</button>
```


При натисканні на цю кнопку має відкриватись модальне вікно Modal з формою NoteForm. Компонент Modal має створювати DOM-елемент наступної структури:


```ts
<div
  className={css.backdrop}
  role="dialog"
  aria-modal="true"
>
  <div className={css.modal}>
    {/* */}
  </div>
</div>
```


Модальне вікно має створюватись через createPortal, щоб рендерити модалку поза межами основного дерева компонентів, та закриватися при кліку на бекдроп і натисканням на клавішу Escape.



Компонент NoteForm має створювати DOM-елемент наступної структури:


```html
<form className={css.form}>
  <div className={css.formGroup}>
    <label htmlFor="title">Title</label>
    <input id="title" type="text" name="title" className={css.input} />
    <span name="title" className={css.error} />
  </div>

  <div className={css.formGroup}>
    <label htmlFor="content">Content</label>
    <textarea
      id="content"
      name="content"
      rows={8}
      className={css.textarea}
    />
    <span name="content" className={css.error} />
  </div>

  <div className={css.formGroup}>
    <label htmlFor="tag">Tag</label>
    <select id="tag" name="tag" className={css.select}>
      <option value="Todo">Todo</option>
      <option value="Work">Work</option>
      <option value="Personal">Personal</option>
      <option value="Meeting">Meeting</option>
      <option value="Shopping">Shopping</option>
    </select>
    <span name="tag" className={css.error} />
  </div>

  <div className={css.actions}>
    <button type="button" className={css.cancelButton}>
      Cancel
    </button>
    <button
      type="submit"
      className={css.submitButton}
      disabled=false
    >
      Create note
    </button>
  </div>
</form>
```


Для керування станом форми, валідації та обробки сабміту слід використовувати бібліотеку Formik.



Додай валідацію значень полів форми за допомогою Yup:

заголовок нотатки має мати мінімальну довжину символів 3, максимальну – 50 та бути обовязковим полем;
контент нотатки має мати максимальну довжину символів 500;
тег нотатки має бути одним із таких значень: Todo, Work, Personal, Meeting, Shopping, і є обов’язковим полем.


### Видалення нотатки



При натисканні на кнопку Delete в елементі списку нотаток, відповідна нотатка має видалятися на бекенді та оновлюватись збережені серверні дані.



### Пошук



Додайте в хедер застосунку компонент SearchBox. Він має створювати DOM-елемент наступної структури:


```html
<input
  className={css.input}
  type="text"
  placeholder="Search notes"
 />
```


Користувач може шукати нотатки за допомогою текстового поля, при зміні значення якого на бекенд відправляється запит для отримання нотаток, які підходять під пошук. Для цього до запиту потрібно додати параметр search із текстовим значенням для пошуку:



GET https://notehub-public.goit.study/api/notes?search=mysearchtext



Обов’язково зробіть відкладений пошук з use-debounce, щоб не виконувати запит на кожний введений символ. Хук useDebounce варто використовувати саме в Арр і передавати відкладене пошукове слово у залежності в useQuery.



### Додатково



Рекомендуємо створити окремі компоненти для відображення індикатора завантаження під час виконання HTTP-запитів, повідомлень про помилки та інших статусів запиту.





# Результати
### Завдання вирішено правильно (файл note)

Добре виконані аспекти:

Інтерфейс Note правильно визначений та експортований з усіма необхідними властивостями.
Властивість tag в Note має тип string, що є прийнятним.
Фінальне рішення:

Завдання прийнято


### Завдання вирішено правильно (файл noteService)

Добре виконані аспекти:

У всіх axios-запитах явно вказані дженерик типи для забезпечення типобезпеки.
Заголовок авторизації включено у всі запити.
Коректне використання імпортованого типу Note та відсутність локального оголошення інтерфейсу Note.
Функція отримання нотаток підтримує пошук і пагінацію, а також повертає правильну структуру відповіді.
Фінальне рішення:

Завдання  прийнято


### Завдання вирішено правильно (файл NoteForm)

Добре виконані аспекти:

Коректне використання Formik для керування станом форми та Yup для валідації.
Усі обов'язкові поля (title, content, tag) присутні з правильними типами вводу.
Помилки валідації відображаються біля полів за допомогою ErrorMessage.
Реалізована інтеграція з TanStack Query для мутацій та інвалідації запитів.
Усі змінні та пропси правильно типізовані, не використовується тип any.
Остаточне рішення:

Завдання прийнято


### Завдання вирішено правильно (файл NoteList)

Завдання прийнято

Добре виконані аспекти:

Усі необхідні поля нотатки (title, content, tag) відображаються для кожної нотатки.
Функціонал видалення коректно реалізовано з використанням useMutation з TanStack Query.
Інвалідація кешу запитів оброблена належним чином за допомогою queryClient.invalidateQueries.
Пропси та параметри функцій коректно типізовані, тип Note імпортовано.
Остаточне рішення:

Завдання прийнято


### Завдання вирішено правильно (файл Modal)

Завдання прийнято

Добре реалізовані аспекти:

Контент модального вікна відображається через children і коректно типізований як React.ReactNode.
Функція onClose типізована та використовується правильно.
Модальне вікно закривається при кліку на бекдроп із коректною перевіркою цільового елементу події.
Модальне вікно закривається по клавіші Escape, що обробляється через useEffect з правильним очищенням ефекту.
Модальне вікно рендериться за допомогою createPortal.
Всі пропси та параметри функцій коректно типізовані; не використовується any.
Код чистий і добре структурований.
Додаткові поради:

Розгляньте імплементацію блокування прокрутки (наприклад, шляхом встановлення overflow: hidden для body) задля повного вимкнення прокрутки сторінки при відкритому модальному вікні.
Остаточне рішення:

Завдання було прийнято


### Завдання вирішено правильно (файл Pagination)

Добре виконані аспекти:

Усі змінні та параметри функцій явно типізовані.
Компонент ReactPaginate відображається з необхідними пропсами.
Зворотний виклик для зміни сторінки коректно обробляється та типізується.
Стилізація здійснюється через CSS-модулі.
Остаточне рішення:

Завдання прийнято


### Завдання вирішено правильно (файл SearchBox)

Добре виконані аспекти:

Компонент названо і експортовано як SearchBox.
Поле вводу реалізовано як звичайний інпут, а не форма.
Обробник зміни інпуту має коректну типізацію.
Відсутнє використання any або неявного any.
Інпут приймає callback для змін значення.
Фінальне рішення:

Завдання прийнято


### Завдання вирішено правильно (файл App)

Добре виконані аспекти:

Код використовує TanStack Query із коректними queryKey та queryFn для отримання нотаток.
Дебаунсований пошук реалізовано за допомогою useDebouncedCallback.
Стан відкриття/закриття модального вікна керується правильно, і модалка рендерить NoteForm як дочірній компонент.
Компоненти пагінації та пошукового поля рендеряться з відповідними пропсами.
Дотримується типобезпечність, відсутнє використання any або неявного any.
Фінальне рішення:

Завдання прийнято


### Завдання вирішено правильно (файл main)

Завдання прийнято

Добре виконані аспекти:

Коректно імпортує і QueryClient, і QueryClientProvider з @tanstack/react-query.
Правильно створює екземпляр QueryClient.
Обгортає кореневий компонент у QueryClientProvider та передає екземпляр queryClient.
Підтримує чисту та організовану структуру коду.
Містить опціональну інтеграцію ReactQueryDevtools для покращення досвіду розробки.
Остаточне рішення:

Завдання прийнято
